{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/shared/schema.ts"],"sourcesContent":["import { sql } from 'drizzle-orm';\nimport {\n  index,\n  jsonb,\n  pgTable,\n  timestamp,\n  varchar,\n  text,\n  serial,\n} from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\n// Session storage table.\n// (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.\nexport const sessions = pgTable(\n  \"sessions\",\n  {\n    sid: varchar(\"sid\").primaryKey(),\n    sess: jsonb(\"sess\").notNull(),\n    expire: timestamp(\"expire\").notNull(),\n  },\n  (table) => [index(\"IDX_session_expire\").on(table.expire)],\n);\n\n// User storage table.\n// (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.\nexport const users = pgTable(\"users\", {\n  id: varchar(\"id\").primaryKey().default(sql`gen_random_uuid()`),\n  email: varchar(\"email\").unique(),\n  firstName: varchar(\"first_name\"),\n  lastName: varchar(\"last_name\"),\n  profileImageUrl: varchar(\"profile_image_url\"),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  updatedAt: timestamp(\"updated_at\").defaultNow(),\n});\n\nexport type UpsertUser = typeof users.$inferInsert;\nexport type User = typeof users.$inferSelect;\n\n// Generation history table for storing user's past generations\nexport const generations = pgTable(\"generations\", {\n  id: serial(\"id\").primaryKey(),\n  userId: varchar(\"user_id\").notNull().references(() => users.id),\n  toolType: varchar(\"tool_type\", { length: 50 }).notNull(),\n  inputs: jsonb(\"inputs\").notNull(),\n  output: text(\"output\").notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n});\n\nexport const insertGenerationSchema = createInsertSchema(generations).omit({\n  id: true,\n  createdAt: true,\n});\nexport type InsertGeneration = z.infer<typeof insertGenerationSchema>;\nexport type Generation = typeof generations.$inferSelect;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AASA;;;;;;;;;;AAKO,MAAM,WAAW,IAAA,mKAAO,EAC7B,YACA;IACE,KAAK,IAAA,mKAAO,EAAC,OAAO,UAAU;IAC9B,MAAM,IAAA,iKAAK,EAAC,QAAQ,OAAO;IAC3B,QAAQ,IAAA,qKAAS,EAAC,UAAU,OAAO;AACrC,GACA,CAAC,QAAU;QAAC,IAAA,iKAAK,EAAC,sBAAsB,EAAE,CAAC,MAAM,MAAM;KAAE;AAKpD,MAAM,QAAQ,IAAA,mKAAO,EAAC,SAAS;IACpC,IAAI,IAAA,mKAAO,EAAC,MAAM,UAAU,GAAG,OAAO,CAAC,mIAAG,CAAC,iBAAiB,CAAC;IAC7D,OAAO,IAAA,mKAAO,EAAC,SAAS,MAAM;IAC9B,WAAW,IAAA,mKAAO,EAAC;IACnB,UAAU,IAAA,mKAAO,EAAC;IAClB,iBAAiB,IAAA,mKAAO,EAAC;IACzB,WAAW,IAAA,qKAAS,EAAC,cAAc,UAAU;IAC7C,WAAW,IAAA,qKAAS,EAAC,cAAc,UAAU;AAC/C;AAMO,MAAM,cAAc,IAAA,mKAAO,EAAC,eAAe;IAChD,IAAI,IAAA,kKAAM,EAAC,MAAM,UAAU;IAC3B,QAAQ,IAAA,mKAAO,EAAC,WAAW,OAAO,GAAG,UAAU,CAAC,IAAM,MAAM,EAAE;IAC9D,UAAU,IAAA,mKAAO,EAAC,aAAa;QAAE,QAAQ;IAAG,GAAG,OAAO;IACtD,QAAQ,IAAA,iKAAK,EAAC,UAAU,OAAO;IAC/B,QAAQ,IAAA,gKAAI,EAAC,UAAU,OAAO;IAC9B,WAAW,IAAA,qKAAS,EAAC,cAAc,UAAU;AAC/C;AAEO,MAAM,yBAAyB,IAAA,kJAAkB,EAAC,aAAa,IAAI,CAAC;IACzE,IAAI;IACJ,WAAW;AACb"}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/db.ts"],"sourcesContent":["import { drizzle } from \"drizzle-orm/node-postgres\";\nimport pg from \"pg\";\nimport * as schema from \"../shared/schema\";\n\nconst { Pool } = pg;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle(pool, { schema });\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;;;;;;;AAEA,MAAM,EAAE,IAAI,EAAE,GAAG,+GAAE;AAEnB,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;IAC7B,MAAM,IAAI,MACR;AAEJ;AAEO,MAAM,OAAO,IAAI,KAAK;IAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAAC;AACnE,MAAM,KAAK,IAAA,+KAAO,EAAC,MAAM;IAAE,QAAA;AAAO"}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/storage.ts"],"sourcesContent":["import {\n  users,\n  generations,\n  type User,\n  type UpsertUser,\n  type Generation,\n  type InsertGeneration,\n} from \"../shared/schema\";\nimport { db } from \"./db\";\nimport { eq, desc } from \"drizzle-orm\";\n\n// Interface for storage operations\nexport interface IStorage {\n  // User operations (mandatory for Replit Auth)\n  getUser(id: string): Promise<User | undefined>;\n  upsertUser(user: UpsertUser): Promise<User>;\n  // Generation operations\n  createGeneration(generation: InsertGeneration): Promise<Generation>;\n  getGenerations(userId: string): Promise<Generation[]>;\n  getGeneration(id: number): Promise<Generation | undefined>;\n  deleteGeneration(id: number): Promise<void>;\n}\n\nexport class DatabaseStorage implements IStorage {\n  // User operations (mandatory for Replit Auth)\n  async getUser(id: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.id, id));\n    return user;\n  }\n\n  async upsertUser(userData: UpsertUser): Promise<User> {\n    const [user] = await db\n      .insert(users)\n      .values(userData)\n      .onConflictDoUpdate({\n        target: users.id,\n        set: {\n          ...userData,\n          updatedAt: new Date(),\n        },\n      })\n      .returning();\n    return user;\n  }\n\n  // Generation operations\n  async createGeneration(generation: InsertGeneration): Promise<Generation> {\n    const [created] = await db.insert(generations).values(generation).returning();\n    return created;\n  }\n\n  async getGenerations(userId: string): Promise<Generation[]> {\n    return await db\n      .select()\n      .from(generations)\n      .where(eq(generations.userId, userId))\n      .orderBy(desc(generations.createdAt));\n  }\n\n  async getGeneration(id: number): Promise<Generation | undefined> {\n    const [generation] = await db\n      .select()\n      .from(generations)\n      .where(eq(generations.id, id));\n    return generation;\n  }\n\n  async deleteGeneration(id: number): Promise<void> {\n    await db.delete(generations).where(eq(generations.id, id));\n  }\n}\n\nexport const storage = new DatabaseStorage();\n"],"names":[],"mappings":";;;;;;AAAA;AAQA;AACA;;;;;;;;;;AAcO,MAAM;IACX,8CAA8C;IAC9C,MAAM,QAAQ,EAAU,EAA6B;QACnD,MAAM,CAAC,KAAK,GAAG,MAAM,2GAAE,CAAC,MAAM,GAAG,IAAI,CAAC,kHAAK,EAAE,KAAK,CAAC,IAAA,kIAAE,EAAC,kHAAK,CAAC,EAAE,EAAE;QAChE,OAAO;IACT;IAEA,MAAM,WAAW,QAAoB,EAAiB;QACpD,MAAM,CAAC,KAAK,GAAG,MAAM,2GAAE,CACpB,MAAM,CAAC,kHAAK,EACZ,MAAM,CAAC,UACP,kBAAkB,CAAC;YAClB,QAAQ,kHAAK,CAAC,EAAE;YAChB,KAAK;gBACH,GAAG,QAAQ;gBACX,WAAW,IAAI;YACjB;QACF,GACC,SAAS;QACZ,OAAO;IACT;IAEA,wBAAwB;IACxB,MAAM,iBAAiB,UAA4B,EAAuB;QACxE,MAAM,CAAC,QAAQ,GAAG,MAAM,2GAAE,CAAC,MAAM,CAAC,wHAAW,EAAE,MAAM,CAAC,YAAY,SAAS;QAC3E,OAAO;IACT;IAEA,MAAM,eAAe,MAAc,EAAyB;QAC1D,OAAO,MAAM,2GAAE,CACZ,MAAM,GACN,IAAI,CAAC,wHAAW,EAChB,KAAK,CAAC,IAAA,kIAAE,EAAC,wHAAW,CAAC,MAAM,EAAE,SAC7B,OAAO,CAAC,IAAA,oIAAI,EAAC,wHAAW,CAAC,SAAS;IACvC;IAEA,MAAM,cAAc,EAAU,EAAmC;QAC/D,MAAM,CAAC,WAAW,GAAG,MAAM,2GAAE,CAC1B,MAAM,GACN,IAAI,CAAC,wHAAW,EAChB,KAAK,CAAC,IAAA,kIAAE,EAAC,wHAAW,CAAC,EAAE,EAAE;QAC5B,OAAO;IACT;IAEA,MAAM,iBAAiB,EAAU,EAAiB;QAChD,MAAM,2GAAE,CAAC,MAAM,CAAC,wHAAW,EAAE,KAAK,CAAC,IAAA,kIAAE,EAAC,wHAAW,CAAC,EAAE,EAAE;IACxD;AACF;AAEO,MAAM,UAAU,IAAI"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/auth.ts"],"sourcesContent":["import * as client from \"openid-client\";\nimport memoize from \"memoizee\";\nimport { storage } from \"../server/storage\";\n\nexport const getOidcConfig = memoize(\n  async () => {\n    return await client.discovery(\n      new URL(process.env.ISSUER_URL ?? \"https://replit.com/oidc\"),\n      process.env.REPL_ID!\n    );\n  },\n  { maxAge: 3600 * 1000 }\n);\n\nexport async function upsertUser(claims: any) {\n  await storage.upsertUser({\n    id: claims[\"sub\"],\n    email: claims[\"email\"],\n    firstName: claims[\"first_name\"],\n    lastName: claims[\"last_name\"],\n    profileImageUrl: claims[\"profile_image_url\"],\n  });\n}\n\nexport function getCallbackUrl(req: { headers: { host?: string }; url?: string }) {\n  const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';\n  const host = req.headers.host || 'localhost:5000';\n  return `${protocol}://${host}/api/callback`;\n}\n\nexport function getBaseUrl(req: { headers: { host?: string } }) {\n  const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';\n  const host = req.headers.host || 'localhost:5000';\n  return `${protocol}://${host}`;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;AAEO,MAAM,gBAAgB,IAAA,oHAAO,EAClC;IACE,OAAO,MAAM,6IAAgB,CAC3B,IAAI,IAAI,QAAQ,GAAG,CAAC,UAAU,IAAI,4BAClC,QAAQ,GAAG,CAAC,OAAO;AAEvB,GACA;IAAE,QAAQ,OAAO;AAAK;AAGjB,eAAe,WAAW,MAAW;IAC1C,MAAM,qHAAO,CAAC,UAAU,CAAC;QACvB,IAAI,MAAM,CAAC,MAAM;QACjB,OAAO,MAAM,CAAC,QAAQ;QACtB,WAAW,MAAM,CAAC,aAAa;QAC/B,UAAU,MAAM,CAAC,YAAY;QAC7B,iBAAiB,MAAM,CAAC,oBAAoB;IAC9C;AACF;AAEO,SAAS,eAAe,GAAiD;IAC9E,MAAM,WAAW,sCAAwC,0BAAU;IACnE,MAAM,OAAO,IAAI,OAAO,CAAC,IAAI,IAAI;IACjC,OAAO,GAAG,SAAS,GAAG,EAAE,KAAK,aAAa,CAAC;AAC7C;AAEO,SAAS,WAAW,GAAmC;IAC5D,MAAM,WAAW,sCAAwC,0BAAU;IACnE,MAAM,OAAO,IAAI,OAAO,CAAC,IAAI,IAAI;IACjC,OAAO,GAAG,SAAS,GAAG,EAAE,MAAM;AAChC"}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/session.ts"],"sourcesContent":["import type { NextApiRequest, NextApiResponse } from 'next';\nimport { parse } from 'cookie';\nimport * as client from \"openid-client\";\nimport { getOidcConfig } from './auth';\n\nexport interface UserSession {\n  claims: any;\n  access_token: string;\n  refresh_token?: string;\n  expires_at?: number;\n}\n\nexport function getSessionFromCookie(req: NextApiRequest): UserSession | null {\n  const cookies = parse(req.headers.cookie || '');\n  const sessionCookie = cookies.session;\n  \n  if (!sessionCookie) {\n    return null;\n  }\n  \n  try {\n    const sessionData = Buffer.from(sessionCookie, 'base64').toString('utf-8');\n    return JSON.parse(sessionData);\n  } catch {\n    return null;\n  }\n}\n\nexport async function validateSession(session: UserSession): Promise<boolean> {\n  if (!session || !session.expires_at) {\n    return false;\n  }\n  \n  const now = Math.floor(Date.now() / 1000);\n  if (now <= session.expires_at) {\n    return true;\n  }\n  \n  if (!session.refresh_token) {\n    return false;\n  }\n  \n  try {\n    const config = await getOidcConfig();\n    await client.refreshTokenGrant(config, session.refresh_token);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport type AuthHandler = (\n  req: NextApiRequest, \n  res: NextApiResponse, \n  session: UserSession\n) => Promise<void>;\n\nexport function withAuth(handler: AuthHandler) {\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    const session = getSessionFromCookie(req);\n    \n    if (!session) {\n      return res.status(401).json({ message: \"Unauthorized\" });\n    }\n    \n    const isValid = await validateSession(session);\n    if (!isValid) {\n      return res.status(401).json({ message: \"Unauthorized\" });\n    }\n    \n    return handler(req, res, session);\n  };\n}\n"],"names":[],"mappings":";;;;;;;;AACA;AACA;AACA;;;;;;;;;AASO,SAAS,qBAAqB,GAAmB;IACtD,MAAM,UAAU,IAAA,8GAAK,EAAC,IAAI,OAAO,CAAC,MAAM,IAAI;IAC5C,MAAM,gBAAgB,QAAQ,OAAO;IAErC,IAAI,CAAC,eAAe;QAClB,OAAO;IACT;IAEA,IAAI;QACF,MAAM,cAAc,OAAO,IAAI,CAAC,eAAe,UAAU,QAAQ,CAAC;QAClE,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,gBAAgB,OAAoB;IACxD,IAAI,CAAC,WAAW,CAAC,QAAQ,UAAU,EAAE;QACnC,OAAO;IACT;IAEA,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IACpC,IAAI,OAAO,QAAQ,UAAU,EAAE;QAC7B,OAAO;IACT;IAEA,IAAI,CAAC,QAAQ,aAAa,EAAE;QAC1B,OAAO;IACT;IAEA,IAAI;QACF,MAAM,SAAS,MAAM,IAAA,qHAAa;QAClC,MAAM,qJAAwB,CAAC,QAAQ,QAAQ,aAAa;QAC5D,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAQO,SAAS,SAAS,OAAoB;IAC3C,OAAO,OAAO,KAAqB;QACjC,MAAM,UAAU,qBAAqB;QAErC,IAAI,CAAC,SAAS;YACZ,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,SAAS;YAAe;QACxD;QAEA,MAAM,UAAU,MAAM,gBAAgB;QACtC,IAAI,CAAC,SAAS;YACZ,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,SAAS;YAAe;QACxD;QAEA,OAAO,QAAQ,KAAK,KAAK;IAC3B;AACF"}},
    {"offset": {"line": 369, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/pages/api/auth/user.ts"],"sourcesContent":["import type { NextApiRequest, NextApiResponse } from 'next';\nimport { withAuth, UserSession } from '../../../lib/session';\nimport { storage } from '../../../server/storage';\n\nasync function handler(\n  req: NextApiRequest, \n  res: NextApiResponse,\n  session: UserSession\n) {\n  try {\n    const userId = session.claims?.sub;\n    if (!userId) {\n      return res.status(401).json({ message: \"Unauthorized\" });\n    }\n    \n    const user = await storage.getUser(userId);\n    res.json(user);\n  } catch (error) {\n    console.error(\"Error fetching user:\", error);\n    res.status(500).json({ message: \"Failed to fetch user\" });\n  }\n}\n\nexport default withAuth(handler);\n"],"names":[],"mappings":";;;;AACA;AACA;;;;;;;;AAEA,eAAe,QACb,GAAmB,EACnB,GAAoB,EACpB,OAAoB;IAEpB,IAAI;QACF,MAAM,SAAS,QAAQ,MAAM,EAAE;QAC/B,IAAI,CAAC,QAAQ;YACX,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,SAAS;YAAe;QACxD;QAEA,MAAM,OAAO,MAAM,qHAAO,CAAC,OAAO,CAAC;QACnC,IAAI,IAAI,CAAC;IACX,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,SAAS;QAAuB;IACzD;AACF;uCAEe,IAAA,mHAAQ,EAAC"}}]
}