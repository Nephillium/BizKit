{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/stripeClient.ts"],"sourcesContent":["import Stripe from 'stripe';\n\nlet connectionSettings: any;\n\nasync function getReplitCredentials() {\n  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME;\n  const xReplitToken = process.env.REPL_IDENTITY\n    ? 'repl ' + process.env.REPL_IDENTITY\n    : process.env.WEB_REPL_RENEWAL\n      ? 'depl ' + process.env.WEB_REPL_RENEWAL\n      : null;\n\n  if (!xReplitToken || !hostname) {\n    return null;\n  }\n\n  try {\n    const connectorName = 'stripe';\n    const isProduction = process.env.REPLIT_DEPLOYMENT === '1';\n    const targetEnvironment = isProduction ? 'production' : 'development';\n\n    const url = new URL(`https://${hostname}/api/v2/connection`);\n    url.searchParams.set('include_secrets', 'true');\n    url.searchParams.set('connector_names', connectorName);\n    url.searchParams.set('environment', targetEnvironment);\n\n    const response = await fetch(url.toString(), {\n      headers: {\n        'Accept': 'application/json',\n        'X_REPLIT_TOKEN': xReplitToken\n      }\n    });\n\n    const data = await response.json();\n    connectionSettings = data.items?.[0];\n\n    if (!connectionSettings || (!connectionSettings.settings.publishable || !connectionSettings.settings.secret)) {\n      return null;\n    }\n\n    return {\n      publishableKey: connectionSettings.settings.publishable,\n      secretKey: connectionSettings.settings.secret,\n    };\n  } catch (error) {\n    console.error('Failed to get Replit Stripe credentials:', error);\n    return null;\n  }\n}\n\nasync function getCredentials() {\n  // First try Replit connector\n  const replitCreds = await getReplitCredentials();\n  if (replitCreds) {\n    return replitCreds;\n  }\n\n  // Fallback to environment variables (for Vercel/other deployments)\n  const secretKey = process.env.STRIPE_SECRET_KEY;\n  const publishableKey = process.env.STRIPE_PUBLISHABLE_KEY;\n\n  if (!secretKey) {\n    throw new Error('Stripe not configured: STRIPE_SECRET_KEY missing');\n  }\n\n  return {\n    publishableKey: publishableKey || '',\n    secretKey,\n  };\n}\n\nexport async function getUncachableStripeClient() {\n  const { secretKey } = await getCredentials();\n  return new Stripe(secretKey);\n}\n\nexport async function getStripePublishableKey() {\n  const { publishableKey } = await getCredentials();\n  return publishableKey;\n}\n\nexport async function getStripeSecretKey() {\n  const { secretKey } = await getCredentials();\n  return secretKey;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;;;AAEA,IAAI;AAEJ,eAAe;IACb,MAAM,WAAW,QAAQ,GAAG,CAAC,0BAA0B;IACvD,MAAM,eAAe,QAAQ,GAAG,CAAC,aAAa,GAC1C,UAAU,QAAQ,GAAG,CAAC,aAAa,GACnC,QAAQ,GAAG,CAAC,gBAAgB,GAC1B,UAAU,QAAQ,GAAG,CAAC,gBAAgB,GACtC;IAEN,IAAI,CAAC,gBAAgB,CAAC,UAAU;QAC9B,OAAO;IACT;IAEA,IAAI;QACF,MAAM,gBAAgB;QACtB,MAAM,eAAe,QAAQ,GAAG,CAAC,iBAAiB,KAAK;QACvD,MAAM,oBAAoB,eAAe,eAAe;QAExD,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE,SAAS,kBAAkB,CAAC;QAC3D,IAAI,YAAY,CAAC,GAAG,CAAC,mBAAmB;QACxC,IAAI,YAAY,CAAC,GAAG,CAAC,mBAAmB;QACxC,IAAI,YAAY,CAAC,GAAG,CAAC,eAAe;QAEpC,MAAM,WAAW,MAAM,MAAM,IAAI,QAAQ,IAAI;YAC3C,SAAS;gBACP,UAAU;gBACV,kBAAkB;YACpB;QACF;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAChC,qBAAqB,KAAK,KAAK,EAAE,CAAC,EAAE;QAEpC,IAAI,CAAC,sBAAuB,CAAC,mBAAmB,QAAQ,CAAC,WAAW,IAAI,CAAC,mBAAmB,QAAQ,CAAC,MAAM,EAAG;YAC5G,OAAO;QACT;QAEA,OAAO;YACL,gBAAgB,mBAAmB,QAAQ,CAAC,WAAW;YACvD,WAAW,mBAAmB,QAAQ,CAAC,MAAM;QAC/C;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4CAA4C;QAC1D,OAAO;IACT;AACF;AAEA,eAAe;IACb,6BAA6B;IAC7B,MAAM,cAAc,MAAM;IAC1B,IAAI,aAAa;QACf,OAAO;IACT;IAEA,mEAAmE;IACnE,MAAM,YAAY,QAAQ,GAAG,CAAC,iBAAiB;IAC/C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,sBAAsB;IAEzD,IAAI,CAAC,WAAW;QACd,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;QACL,gBAAgB,kBAAkB;QAClC;IACF;AACF;AAEO,eAAe;IACpB,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM;IAC5B,OAAO,IAAI,uHAAM,CAAC;AACpB;AAEO,eAAe;IACpB,MAAM,EAAE,cAAc,EAAE,GAAG,MAAM;IACjC,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM;IAC5B,OAAO;AACT"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/db.ts"],"sourcesContent":["import { Pool } from 'pg';\n\nlet connectionString = process.env.DATABASE_URL || '';\nif (connectionString.startsWith(\"psql \")) {\n  connectionString = connectionString.replace(\"psql \", \"\").replace(/^'|'$/g, \"\");\n}\n\nconst pool = new Pool({\n  connectionString,\n  ssl: { rejectUnauthorized: false },\n});\n\nexport async function query<T = any>(text: string, params?: any[]): Promise<T[]> {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(text, params);\n    return result.rows;\n  } finally {\n    client.release();\n  }\n}\n\nexport async function queryOne<T = any>(text: string, params?: any[]): Promise<T | null> {\n  const rows = await query<T>(text, params);\n  return rows[0] || null;\n}\n\nexport async function execute(text: string, params?: any[]): Promise<number> {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(text, params);\n    return result.rowCount || 0;\n  } finally {\n    client.release();\n  }\n}\n\nexport { pool };\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;;AAEA,IAAI,mBAAmB,QAAQ,GAAG,CAAC,YAAY,IAAI;AACnD,IAAI,iBAAiB,UAAU,CAAC,UAAU;IACxC,mBAAmB,iBAAiB,OAAO,CAAC,SAAS,IAAI,OAAO,CAAC,UAAU;AAC7E;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB;IACA,KAAK;QAAE,oBAAoB;IAAM;AACnC;AAEO,eAAe,MAAe,IAAY,EAAE,MAAc;IAC/D,MAAM,SAAS,MAAM,KAAK,OAAO;IACjC,IAAI;QACF,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC,MAAM;QACxC,OAAO,OAAO,IAAI;IACpB,SAAU;QACR,OAAO,OAAO;IAChB;AACF;AAEO,eAAe,SAAkB,IAAY,EAAE,MAAc;IAClE,MAAM,OAAO,MAAM,MAAS,MAAM;IAClC,OAAO,IAAI,CAAC,EAAE,IAAI;AACpB;AAEO,eAAe,QAAQ,IAAY,EAAE,MAAc;IACxD,MAAM,SAAS,MAAM,KAAK,OAAO;IACjC,IAAI;QACF,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC,MAAM;QACxC,OAAO,OAAO,QAAQ,IAAI;IAC5B,SAAU;QACR,OAAO,OAAO;IAChB;AACF"}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/users.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\nimport { sign, verify } from 'jsonwebtoken';\nimport { query, queryOne, pool } from './db';\n\nexport type UserRole = 'user' | 'admin';\n\nexport interface User {\n  id: string;\n  email: string;\n  password_hash: string;\n  role: UserRole;\n  credits: number;\n  usage_count: number;\n  created_at: Date;\n}\n\nexport interface JWTPayload {\n  id: string;\n  email: string;\n  role: UserRole;\n}\n\nconst JWT_SECRET = process.env.JWT_SECRET || process.env.SESSION_SECRET || 'bizkit-dev-secret';\nconst SUPER_USER_EMAIL = process.env.SUPER_USER_EMAIL;\nconst SALT_ROUNDS = 10;\n\nasync function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS);\n}\n\nasync function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}\n\nexport function isUserSuperUser(email: string): boolean {\n  if (!SUPER_USER_EMAIL) return false;\n  return email.toLowerCase().trim() === SUPER_USER_EMAIL.toLowerCase().trim();\n}\n\nexport async function findUserByEmail(email: string): Promise<User | null> {\n  return queryOne<User>(\n    'SELECT id, email, password_hash, role, credits, usage_count, created_at FROM users WHERE email = $1',\n    [email.toLowerCase().trim()]\n  );\n}\n\nexport async function findUserById(id: string): Promise<User | null> {\n  return queryOne<User>(\n    'SELECT id, email, password_hash, role, credits, usage_count, created_at FROM users WHERE id = $1',\n    [id]\n  );\n}\n\nexport async function registerUser(\n  email: string, \n  password: string\n): Promise<User | { error: string }> {\n  const normalizedEmail = email.toLowerCase().trim();\n  \n  const existing = await findUserByEmail(normalizedEmail);\n  if (existing) {\n    return { error: 'User already exists' };\n  }\n  \n  const passwordHash = await hashPassword(password);\n  const role: UserRole = isUserSuperUser(normalizedEmail) ? 'admin' : 'user';\n  \n  const result = await queryOne<User>(\n    `INSERT INTO users (email, password_hash, role, credits, usage_count) \n     VALUES ($1, $2, $3, $4, $5) \n     RETURNING id, email, password_hash, role, credits, usage_count, created_at`,\n    [normalizedEmail, passwordHash, role, 0, 0]\n  );\n  \n  if (!result) {\n    return { error: 'Failed to create user' };\n  }\n  \n  return result;\n}\n\nexport async function loginUser(\n  email: string, \n  password: string\n): Promise<{ token: string; user: Omit<User, 'password_hash'> } | { error: string }> {\n  const normalizedEmail = email.toLowerCase().trim();\n  \n  const user = await findUserByEmail(normalizedEmail);\n  if (!user) {\n    return { error: 'Invalid email or password' };\n  }\n  \n  const valid = await verifyPassword(password, user.password_hash);\n  if (!valid) {\n    return { error: 'Invalid email or password' };\n  }\n  \n  let role = user.role;\n  if (isUserSuperUser(normalizedEmail) && role !== 'admin') {\n    await query('UPDATE users SET role = $1 WHERE id = $2', ['admin', user.id]);\n    role = 'admin';\n  }\n  \n  const token = generateToken({ ...user, role });\n  const { password_hash, ...userWithoutPassword } = { ...user, role };\n  return { token, user: userWithoutPassword };\n}\n\nexport function generateToken(user: { id: string; email: string; role: UserRole }): string {\n  const payload: JWTPayload = {\n    id: user.id,\n    email: user.email,\n    role: user.role,\n  };\n  return sign(payload, JWT_SECRET, { expiresIn: '7d' });\n}\n\nexport function verifyToken(token: string): JWTPayload | null {\n  try {\n    return verify(token, JWT_SECRET) as JWTPayload;\n  } catch {\n    return null;\n  }\n}\n\nexport function getTokenFromCookie(cookieHeader: string | undefined): string | null {\n  if (!cookieHeader) return null;\n  \n  const cookies = cookieHeader.split(';').reduce((acc, cookie) => {\n    const [key, value] = cookie.trim().split('=');\n    acc[key] = value;\n    return acc;\n  }, {} as Record<string, string>);\n  \n  return cookies.bizkit_token || null;\n}\n\nexport function getUserFromRequest(cookieHeader: string | undefined): JWTPayload | null {\n  const token = getTokenFromCookie(cookieHeader);\n  if (!token) return null;\n  return verifyToken(token);\n}\n\nexport async function getUserCredits(userId: string): Promise<number> {\n  const user = await findUserById(userId);\n  return user?.credits ?? 0;\n}\n\nexport async function addCredits(\n  userId: string, \n  amount: number, \n  reason: string\n): Promise<boolean> {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    const result = await client.query(\n      'UPDATE users SET credits = credits + $1 WHERE id = $2 RETURNING credits',\n      [amount, userId]\n    );\n    \n    if (result.rowCount === 0) {\n      await client.query('ROLLBACK');\n      return false;\n    }\n    \n    await client.query(\n      'INSERT INTO credit_transactions (user_id, amount, reason) VALUES ($1, $2, $3)',\n      [userId, amount, reason]\n    );\n    \n    await client.query('COMMIT');\n    return true;\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('Failed to add credits:', error);\n    return false;\n  } finally {\n    client.release();\n  }\n}\n\nexport async function incrementUserUsage(userId: string): Promise<number> {\n  const result = await queryOne<{ usage_count: number }>(\n    'UPDATE users SET usage_count = usage_count + 1 WHERE id = $1 RETURNING usage_count',\n    [userId]\n  );\n  return result?.usage_count ?? 0;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 391, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/pages/api/stripe/create-checkout.ts"],"sourcesContent":["import type { NextApiRequest, NextApiResponse } from 'next';\nimport { getUncachableStripeClient } from '../../../lib/stripeClient';\nimport { getUserFromRequest, findUserById } from '../../../lib/users';\n\nconst PACKS: Record<string, { credits: number; amount: number; name: string }> = {\n  'credits_10': { credits: 10, amount: 500, name: 'BizKit AI - 10 Credit Pack' },\n  'credits_50': { credits: 50, amount: 2000, name: 'BizKit AI - 50 Credit Pack' },\n  'credits_100': { credits: 100, amount: 3500, name: 'BizKit AI - 100 Credit Pack' },\n};\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');\n  res.setHeader('Pragma', 'no-cache');\n  res.setHeader('Expires', '0');\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'method_not_allowed' });\n  }\n\n  try {\n    const jwtPayload = getUserFromRequest(req.headers.cookie);\n    if (!jwtPayload) {\n      return res.status(401).json({ error: 'not_authenticated' });\n    }\n\n    const user = await findUserById(jwtPayload.id);\n    if (!user) {\n      return res.status(401).json({ error: 'user_not_found' });\n    }\n\n    const { packageId } = req.body as { packageId?: string };\n    const pack = packageId ? PACKS[packageId] : undefined;\n\n    if (!pack) {\n      return res.status(400).json({ error: 'invalid_package' });\n    }\n\n    let stripe;\n    try {\n      stripe = await getUncachableStripeClient();\n    } catch (stripeError: any) {\n      console.error('Stripe client error:', stripeError?.message);\n      return res.status(500).json({ \n        error: 'stripe_not_configured',\n        message: stripeError?.message || 'Stripe is not properly configured'\n      });\n    }\n\n    const origin =\n      (req.headers.origin as string) ||\n      `${req.headers['x-forwarded-proto'] || 'https'}://${req.headers.host}`;\n\n    const session = await stripe.checkout.sessions.create({\n      mode: 'payment',\n      payment_method_types: ['card'],\n      line_items: [\n        {\n          price_data: {\n            currency: 'usd',\n            unit_amount: pack.amount,\n            product_data: {\n              name: pack.name,\n              description: `${pack.credits} AI generation credits for BizKit AI`,\n            },\n          },\n          quantity: 1,\n        },\n      ],\n      customer_email: user.email,\n      success_url: `${origin}/buy-credits?success=true&packageId=${encodeURIComponent(packageId || '')}&session_id={CHECKOUT_SESSION_ID}`,\n      cancel_url: `${origin}/buy-credits?canceled=true`,\n      metadata: {\n        userId: user.id.toString(),\n        credits: pack.credits.toString(),\n        packageId: packageId || '',\n      },\n    });\n\n    return res.status(200).json({ url: session.url });\n  } catch (error: any) {\n    console.error('Stripe create-checkout error:', error);\n    return res.status(500).json({\n      error: 'stripe_error',\n      message: error?.message || 'Unknown error',\n    });\n  }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;;;;;;;;AAEA,MAAM,QAA2E;IAC/E,cAAc;QAAE,SAAS;QAAI,QAAQ;QAAK,MAAM;IAA6B;IAC7E,cAAc;QAAE,SAAS;QAAI,QAAQ;QAAM,MAAM;IAA6B;IAC9E,eAAe;QAAE,SAAS;QAAK,QAAQ;QAAM,MAAM;IAA8B;AACnF;AAEe,eAAe,QAAQ,GAAmB,EAAE,GAAoB;IAC7E,IAAI,SAAS,CAAC,iBAAiB;IAC/B,IAAI,SAAS,CAAC,UAAU;IACxB,IAAI,SAAS,CAAC,WAAW;IAEzB,IAAI,IAAI,MAAM,KAAK,QAAQ;QACzB,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAqB;IAC5D;IAEA,IAAI;QACF,MAAM,aAAa,IAAA,2HAAkB,EAAC,IAAI,OAAO,CAAC,MAAM;QACxD,IAAI,CAAC,YAAY;YACf,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAoB;QAC3D;QAEA,MAAM,OAAO,MAAM,IAAA,qHAAY,EAAC,WAAW,EAAE;QAC7C,IAAI,CAAC,MAAM;YACT,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAiB;QACxD;QAEA,MAAM,EAAE,SAAS,EAAE,GAAG,IAAI,IAAI;QAC9B,MAAM,OAAO,YAAY,KAAK,CAAC,UAAU,GAAG;QAE5C,IAAI,CAAC,MAAM;YACT,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAkB;QACzD;QAEA,IAAI;QACJ,IAAI;YACF,SAAS,MAAM,IAAA,yIAAyB;QAC1C,EAAE,OAAO,aAAkB;YACzB,QAAQ,KAAK,CAAC,wBAAwB,aAAa;YACnD,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAC1B,OAAO;gBACP,SAAS,aAAa,WAAW;YACnC;QACF;QAEA,MAAM,SACJ,AAAC,IAAI,OAAO,CAAC,MAAM,IACnB,GAAG,IAAI,OAAO,CAAC,oBAAoB,IAAI,QAAQ,GAAG,EAAE,IAAI,OAAO,CAAC,IAAI,EAAE;QAExE,MAAM,UAAU,MAAM,OAAO,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;YACpD,MAAM;YACN,sBAAsB;gBAAC;aAAO;YAC9B,YAAY;gBACV;oBACE,YAAY;wBACV,UAAU;wBACV,aAAa,KAAK,MAAM;wBACxB,cAAc;4BACZ,MAAM,KAAK,IAAI;4BACf,aAAa,GAAG,KAAK,OAAO,CAAC,oCAAoC,CAAC;wBACpE;oBACF;oBACA,UAAU;gBACZ;aACD;YACD,gBAAgB,KAAK,KAAK;YAC1B,aAAa,GAAG,OAAO,oCAAoC,EAAE,mBAAmB,aAAa,IAAI,iCAAiC,CAAC;YACnI,YAAY,GAAG,OAAO,0BAA0B,CAAC;YACjD,UAAU;gBACR,QAAQ,KAAK,EAAE,CAAC,QAAQ;gBACxB,SAAS,KAAK,OAAO,CAAC,QAAQ;gBAC9B,WAAW,aAAa;YAC1B;QACF;QAEA,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,KAAK,QAAQ,GAAG;QAAC;IACjD,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAC1B,OAAO;YACP,SAAS,OAAO,WAAW;QAC7B;IACF;AACF"}}]
}